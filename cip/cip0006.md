---
owner: "Neil D. Lawrence"
created: "2025-10-12"
id: "0006"
last_updated: "2025-10-12"
status: proposed
tags:
- cip
- refactoring
- modularity
- maintainability
title: "Refactor mlai.py into Modular Structure"
---

# CIP-0006: Refactor mlai.py into Modular Structure

## Summary
Split the monolithic `mlai.py` file (3,423 lines, ~118KB) into logical, focused modules to improve maintainability, readability, and development workflow.

## Motivation
The current `mlai.py` file has grown to an unwieldy size with 3,423 lines containing 87 classes and functions. This creates several problems:

1. **Maintainability**: Difficult to navigate and locate specific functionality
2. **Readability**: Overwhelming for new developers and users
3. **Testing**: Hard to write focused unit tests for specific components
4. **Development**: Multiple developers cannot work on different aspects simultaneously
5. **Import Management**: Users must import the entire module even for specific functionality
6. **Code Organisation**: Related functionality is scattered throughout the large file

The file contains a diverse mix of:
- Utility functions (file I/O, plotting)
- Base model classes
- Linear models and basis functions
- Neural networks and activation functions
- Gaussian processes and kernel functions
- Loss functions
- Clustering and dimensionality reduction algorithms
- Optimisation utilities

## Detailed Description
Refactor `mlai.py` into the following logical modules:

### Phase 1: Core Infrastructure
1. **`utils.py`** - File I/O and utility functions
   - `filename_join()`, `write_animation()`, `write_animation_html()`
   - `write_figure()`, `write_figure_caption()`, `load_pgm()`

2. **`models.py`** - Base model classes and interfaces
   - `Model`, `ProbModel`, `MapModel`, `ProbMapModel`
   - `Noise`, `Gaussian`

3. **`losses.py`** - Loss function implementations
   - `LossFunction` (base class)
   - `MeanSquaredError`, `CrossEntropyLoss`, `BinaryCrossEntropyLoss`
   - `MeanAbsoluteError`, `HuberLoss`

### Phase 2: Core Algorithms
4. **`linear_models.py`** - Linear models, basis functions, and related utilities
   - `LM`, `BLM`, `LR` classes
   - `Basis` class and basis functions (`linear`, `polynomial`, `radial`, `fourier`, `relu`, `hyperbolic_tangent`)

5. **`gaussian_processes.py`** - GP models and all kernel functions
   - `GP` class, `Kernel` class
   - All covariance functions (`eq_cov`, `ou_cov`, `matern32_cov`, `matern52_cov`, etc.)

6. **`neural_networks.py`** - Neural network implementations and activations
   - `SimpleNeuralNetwork`, `SimpleDropoutNeuralNetwork`, `NonparametricDropoutNeuralNetwork`
   - `NeuralNetwork`, activation functions and classes
   - `init_perceptron()`, `update_perceptron()` (perceptron algorithm)

### Phase 3: Specialized Algorithms
7. **`dimred.py`** - Dimensionality reduction and clustering
   - `ClusterModel`, `WardsMethod`
   - `kmeans_*` functions, `ppca_*` functions
   - `generate_swiss_roll()`, `generate_cluster_data()`

8. **`optimisation.py`** - Gradient computation and optimisation utilities
   - `finite_difference_gradient()`, `finite_difference_jacobian()`
   - `verify_gradient_implementation()`

### Import Strategy
- Update `mlai/__init__.py` to import from all modules for backward compatibility
- Maintain existing API surface
- Allow users to import specific modules for better performance

## Implementation Plan
Step-by-step plan for implementing the refactoring:

1. **Phase 1: Core Infrastructure**
   - [ ] Create `utils.py` with file I/O and utility functions
   - [ ] Create `models.py` with base model classes
   - [ ] Create `losses.py` with loss function implementations
   - [ ] Update imports and test basic functionality

2. **Phase 2: Core Algorithms**
   - [ ] Create `linear_models.py` with linear models and basis functions
   - [ ] Create `gaussian_processes.py` with GP models and kernels
   - [ ] Create `neural_networks.py` with neural network implementations
   - [ ] Update imports and test functionality

3. **Phase 3: Specialized Algorithms**
   - [ ] Create `dimred.py` with dimensionality reduction and clustering
   - [ ] Create `optimisation.py` with optimisation utilities
   - [ ] Final testing and validation

4. **Phase 4: Integration and Cleanup**
   - [ ] Update `mlai/__init__.py` to maintain backward compatibility
   - [ ] Update documentation and examples
   - [ ] Remove original `mlai.py` file
   - [ ] Update tests to work with new structure

## Backward Compatibility
This refactoring will maintain full backward compatibility:

- All existing imports (`from mlai import *`) will continue to work
- All class and function names remain unchanged
- API surface remains identical
- Existing code using mlai will not need modifications

The main `mlai/__init__.py` will import everything from the new modules, preserving the current behavior while providing the benefits of modular organization.

## Testing Strategy
Comprehensive testing approach:

1. **Unit Tests**: Create focused unit tests for each new module
2. **Integration Tests**: Ensure all imports work correctly
3. **Backward Compatibility Tests**: Verify existing code continues to work
4. **Performance Tests**: Ensure no performance regression
5. **Documentation Tests**: Verify all examples and tutorials still work

## Benefits
- **Maintainability**: Easier to navigate and modify specific functionality
- **Readability**: Clear separation of concerns
- **Testing**: Focused unit tests for each module
- **Development**: Multiple developers can work on different modules
- **Import Management**: Users can import only what they need
- **Code Organisation**: Related functionality grouped logically

## Risks and Mitigation
- **Risk**: Breaking existing imports
  - **Mitigation**: Comprehensive testing and gradual rollout
- **Risk**: Circular import issues
  - **Mitigation**: Careful dependency analysis and design
- **Risk**: Performance impact
  - **Mitigation**: Benchmarking and optimisation
- **Risk**: Coverage collection interference
  - **Issue**: pytest-cov interferes with numpy's internal state, causing matplotlib failures
  - **Impact**: 7 tests fail with coverage collection (visualization and Ward's method tests)
  - **Mitigation**: Document coverage collection issue before refactoring (see Backlog: 2025-10-12_coverage-collection-numpy-interference)

## Implementation Status
- [x] Create CIP-0006 document
- [x] Document coverage collection interference issue (Backlog: 2025-10-12_coverage-collection-numpy-interference)
- [x] Complete coverage study to identify missing tests
- [x] Add error handling tests for critical functions (26 tests, all passing)
- [x] **COMPLETED: Modular Test Extraction** (2025-10-12)
  - [x] Extracted tests from monolithic `test_mlai.py` (2,943 lines) into 6 modular files
  - [x] Created `test_models.py` (6 tests) - Base model classes
  - [x] Created `test_linear_models.py` (32 tests) - Linear models and basis functions
  - [x] Created `test_gaussian_processes.py` (70 tests) - GP models and kernels
  - [x] Created `test_neural_networks.py` (46 tests) - Neural networks and activations
  - [x] Created `test_experimental.py` (10 tests) - Dropout and experimental features
  - [x] Created `test_utils.py` - Utility functions
  - [x] Created `test_dimred.py` - Dimensionality reduction and clustering
  - [x] Maintained 83% coverage for `mlai.py` (186 tests passing, 7 failing due to matplotlib compatibility)
  - [x] Removed original `test_mlai.py` and committed modular structure
- [ ] Phase 1: Core Infrastructure modules
- [ ] Phase 2: Core Algorithms modules
- [ ] Phase 3: Specialized Algorithms modules
- [ ] Phase 4: Integration and Cleanup
- [ ] Update documentation
- [ ] Final testing and validation

## Required Test Additions

**Current Coverage**: 83% (792/958 statements) - **ACHIEVED through modular test extraction**
**Target Coverage**: 95%+ before refactoring (additional tests may be needed)

**Critical Missing Lines** (155 uncovered statements) - **Organized by Test File:**

## test_models.py (Base Model Classes)
- ~~Lines 165-167: write_figure_caption function~~ ✅ **COVERED**
- ~~Line 377: ProbModel.objective() method~~ ✅ **COVERED**
- Lines 573, 575-579, 583: Model set_param edge cases (LM, BLM classes)

## test_linear_models.py (Linear Models & Basis Functions)
- ~~Line 537: LM constructor error handling~~ ✅ **COVERED**
- Lines 654-655, 659-660: Linear model objective/log_likelihood edge cases
- Lines 783-785, 825: Basis function edge cases (radial, fourier functions)
- Lines 858-861, 863: Basis function edge cases (hyperbolic_tangent function)
- Lines 902-907: Basis function edge cases (relu function)
- Lines 1091, 1093: Dropout network edge cases (NonparametricDropoutNeuralNetwork)
- Lines 2105, 2112-2113: GP set_param edge cases
- Lines 2295-2298, 2325-2335: LR (Logistic Regression) edge cases

## test_gaussian_processes.py (Gaussian Processes)
- Lines 963-971: GP log_likelihood edge cases
- Lines 2431-2432, 2438, 2447-2448, 2457: GP prediction edge cases
- Lines 2549, 2608-2609, 2670-2674: GP optimization edge cases

## test_neural_networks.py (Neural Networks)
- ~~Lines 274-276, 283-285: Perceptron weight update paths~~ ✅ **COVERED**

## test_utils.py (Utility Functions)
- Lines 1617-1640, 1683-1684: Optimization utility functions (finite_difference_gradient, finite_difference_jacobian)
- Lines 2251-2252, 2278: Data generation utility functions (load_pgm, generate_swiss_roll)
- Lines 2783-2786, 2801-2804: Specialized utility functions
- Lines 3132-3154, 3184, 3191-3192, 3196-3202, 3207-3216: Complex utility functions
- Lines 3368-3378, 3383-3394, 3398-3405, 3410-3412, 3417-3423: Advanced utility functions (ppca, clustering)

## test_experimental.py (Experimental Features)
- Lines 1091, 1093: Dropout network edge cases (NonparametricDropoutNeuralNetwork)

## test_dimred.py (Dimensionality Reduction)
- Lines 3132-3154, 3184, 3191-3192, 3196-3202, 3207-3216: Dimensionality reduction algorithms
- Lines 3368-3378, 3383-3394, 3398-3405, 3410-3412, 3417-3423: Clustering algorithms

**Required Test Categories**:
1. **Error Handling Tests**: Critical functions and edge cases
2. **Advanced Algorithm Tests**: Complex neural network and GP features  
3. **Performance Tests**: Memory management and optimization algorithms
4. **Integration Tests**: Cross-module compatibility and advanced features
5. **Edge Case Tests**: Boundary conditions and specialized functionality

## References
- Current `mlai.py` file: `/Users/neil/lawrennd/mlai/mlai/mlai.py`
- Existing module structure: `/Users/neil/lawrennd/mlai/mlai/`
- Coverage analysis: `/Users/neil/lawrennd/mlai/coverage_analysis.md`
- Python packaging best practices
- Modular design principles
